# 5.1 생산자 - 소비자 문제

## 5.1.1 생산자 - 소비자 문제의 정의
생산자 - 소비자 문제
  두 협력 프로세스 사이에 버퍼를 둠
  생산자 : 데이터를 넣는 프로세스
  소비자 : 데이터를 꺼내는 프로세스
  조건 1 : 버퍼에 여러 프로세스가 동시에 접근할 수 없음
    - 상호배제 필요
  조건 2 : 버퍼의 크기가 유한함
    - 동기화 필요
생산자 - 소비자 문제를 유한 버퍼 문제라고도 함
  버퍼가 가득 찬 경우 : 생산자가 기다리게 됨
  버퍼가 빈 경우 : 소비자가 기다리게 됨

## 5.1.2 세마포어를 이용한 해결
3개의 세마포어 이용
  mutex : 상호배제 해결
    - 초깃값 = 1
  empty : 버퍼가 가득 찬 경우의 동기화
    - 초깃값 = 버퍼의 크기 n
  full : 버퍼가 빈 경우의 동기화
    - 초깃값 = 0


// 생산자의  코드
while(true)
{
데이터를 생산
P(empty);
P(mutex);
버퍼에 데이터를 넣음
V(mutex);
V(full);
}

// 소비자의 코드
while(true)
{
P(full);
P(mutex);
버퍼에서 데이터를 꺼냄
V(mutex);
V(empty);
데이터를 소비
}

# 5.2 판독기 - 기록기 문제

## 5.2.1 판독기 - 기록기 문제의 정의
판독기 - 기록기 문제
  여러 협력 프로세스가 파일 같은 공유자원을 사이에 둠
  판독기 : 데이터를 읽는 프로세스
  기록기 : 데이터를 쓰는 프로세스
  조건 1 : 기록기가 공유자원에 데이터를 쓰는 중에는 다른 기록기나 판독기는 공유자원에 접근할 수 없음
    - 상호배제 필요
  조건 2 : 여러 판독기는 동시에 공유자원에서 데이터를 읽을 수 있음
제 1 판독기 - 기록기 문제
  판독기가 공유자원에 접근 중이라면 기록기보다 판독기에 우선순위를 주는 것
  기록기가 기아상태에 빠질 수 있음
제 2 판독기 - 기록기 문제
  판독기가 공유자원에 접근 중일 때 대기 중인 기록기가 있다면 , 새로운 판독기는 조건 2 에도 불구하고 대기함
  판독기의 병행성이 떨어짐
  판독기가 기아상태에 빠질 수 있음

## 5.2.2 세마포어를 이용한 해결
제 1 판독기 - 기록기 문제 : 2개의 세마포어와 하나의 일반 변수 이용
  wrt : 세마포어 기록기에 대한 상호배제 해결
    - 초깃값 = 1
  rcount : 일반 변수 공유자원의 데이터를 읽는 중인 판독기의 개수
    - 초깃값 = 0
  mutex : 세마포어 rcount에 대한 상호배제 해결
    - 초깃값 = 1

// 기록기의 코드
P(wrt);
공유자원에 쓰기
V(wrt);


// 판독기의 코드
P(mutex);
rcount = rcount + 1;
if(rcount == 1 ) then P(wrt);
V(mutex);
공유자원에서 읽기
P(mutex);
rcount = rcount - 1;
if(rcount == 0) then V(wrt);
V(mutex);

제 2 판독기 - 기록기 문제 : 5개의 세마포어와 2개의 일반 변수 이용
  wrt : 세마포어 기록기에 대한 상호배제 해결
    - 초깃값 = 1
  rcount : 일반 변수 공유자원의 데이터를 읽는 중인 판독기의 개수
    - 초깃값 = 0
  mutex1 : 세마포어 rcount에 대한 상호배제 해결
    - 초깃값 = 1
  rd : 세마포어 기록기가 대기 중일 때새로운 판독기에 대한 상호배제 해결
    - 초깃값 = 1
  wcount : 일반 변수 공유자원에 데이터를 쓰거나 쓰기 위해 대기 중인 기록기의 개수
    - 초깃값 = 0
  mutex2 : 세마포어 wcount에 대한 상호배제 해결
    - 초깃값 = 1
  mutex3 : 세마포어 기록기에 우선순위를 주기 위함
    - 초깃값 = 1

// 기록기의 코드
P(mutex2);
wcount = wcount + 1;
if(wcount == 1) then P(rd);
V(mutex2);
P(wrt);
공유자원에 쓰기
V(wrt);
P(mutex2);
wcount = wcount - 1;
if(wcount == 0) then v(rd);
V(mutex2);


// 판독기의 코드
P(mutex3);
P(rd);
P(mutex1);
rcount = rcount + 1;
if(rcount == 1) then P(wrt);
V(mutex1);
V(rd);
V(mutex3);
공유자원에서 읽기
P(mutex1);
rcount = rcount - 1;
if(rcount == 0) then v(wrt);
V(mutex);


# 5.3 프로세스 간 통신

## 5.3.1 공유 메모리 방법
공유 메모리 방법
  협력 프로세스가 공유자원을 이용하는 동일한 변수를 사용함으로써 데이터를 공유하는 방법
고속 통신 가능
통신상 발생할 수 있는 문제는 응용 프로그래머가 책임지고 해결함
  - 통신상 발생할 수 있는 문제 : 상호배제 , 동기화 등
운영체제는 공유 기억장소만 제공


## 5.3.2 메시지 전달방법
메시지 전달방법
  협력 프로세스가 메시지를 주고받으면서 데이터를 공유하는 방법
  커널이 제공하는 연산 send와 연산 receive 이용
  소량의 데이터를 주고받는 데 적합함
  통신상 발생할 수 있는 문제는 운영체제가 책임지고 해결함
통신 링크
  메시지를 주고받는 두 프로세스 사이에 존재함
  통신 링크의 성질
    - 하나의 링크는 오직 두 프로세스만 연결할 수도 있고 여럿 연결할 수도 있음
    - 두 프로세스 사이에 오직 하나의 링크만 존재할 수도 있고 여럿 존재 할 수도 있음
    - 링크의 방향성은 단방향일 수도 있고 양방향일 수도 있음
    - 링크의 용량은 여러 형태로 설정할 수 있음
  직접통신
    두 프로세스가 직접 서로를 지정하여 메시지를 주고받는 방법
    send(B,M) : 프로세스 B로 메시지 M을 보냄
    receive(A,M) : 프로세스 A로부터 메시지를 M에 받음
      - 대칭형 주소 지정
    receive(id,M) : 송신자 이름을 id에 , 메시지를 M에 받음
      - 비대칭혙 주소 지정
    두 프로세스 사이에 오직 하나의 통신 링크만 설정됨
    하나의 링크는 오직 두 프로세스 사이에만 연관됨
    통신 링크는 양방향
  간접통신
    통신을 원하는 프로세스들 사이에 우편함을 두고 이를 통해 메시지를 주고받는 방법
    send(X,m1) : 우편함 X로 메시지 m1을 보냄
    receive(X,m1) : 우편함 X로부터 메시지를 m1에 받음
    두 프로세스 사이에 여러 개의 통신 링크가 존재 가능
    하나의 링크는 여러 프로세스와 연관 가능
    우편함이 수신 프로세스에 소속된 경우
      - 수신자가 하나
      - 통신 링크는 단방향
    우편함이 운영체제에 소속된 경우
      - 수신자가 여럿 가능
      - 한순간에 하나의 수신자만 수신하도록 운영체제가 관리함
      - 송신자와 수신자의 역할이 바뀔 수 있으므로 통신 링크는 양방향













